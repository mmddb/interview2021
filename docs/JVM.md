### 啥算可回收

没有人引用它了；

**引用计数法**

给对象添加 counter，引用一次就 +1，引用失效就 - 1，到 0 就标记为可回收；

but 有循环引用问题，你引用我我引用你，倆都不为 0； 这种方法基本没人用

**可达性分析**

从可作为 GC roots 的对象为起点，从上到下沿着引用链进行搜索，当一个节点没有一条路可以从 GC root 到达时，就证明该对象可回收了。

可以作为 GC roots：**虚拟机栈**（frame中本地变量表中），**本地方法栈**中引用对象；**方法区**中 **静态变量**，**常量引用的对象**，**所有被同步锁持有的对象**。

**三色标记法**

白色：该对象没有被垃圾回收器访问过（可达性分析初始阶段）。

灰色：**该对象**已经被垃圾回收器访问过，但是该对象至少存在一个引用没有被扫描过。

黑色：**该对象**已经被垃圾回收器访问过，并且这个对象的所有引用也已经扫描过。（也就是安全存活的对象，指向他的也是安全存活的）

**标记过程**：

0. 初始状态都是白色
1. 把和 GC root 直接引用的对象标记为灰色，放入灰色集合
2. 判断灰色集合中的对象，存在子引用 -> 把子引用标灰，放入灰色集合； 不存在 -> 移入黑色集合
3. 重复 2，直到所有灰色集合清空，此时，白色对象为 GC Roots 不可达，可以进行垃圾回收

**问题**：并发标记时，运行中的进程会改变引用关系

#### 错误标记：

**多标- 浮动垃圾**：标记到 灰色对象时，该对象对于黑色对象的引用断开，那么这些该回收的的就不会被回收<img src="/Users/jon/Library/Application Support/typora-user-images/截屏2021-10-04 20.37.55.png" alt="截屏2021-10-04 20.37.55" style="zoom:50%;" />

**漏标 **： 该对象**被灰色对象断开**，但是与 **黑色对象连上**

<img src="/Users/jon/Library/Application Support/typora-user-images/截屏2021-10-04 20.38.09.png" alt="截屏2021-10-04 20.38.09" style="zoom:50%;" />

```java
var G = objE.fieldG; // 1.读
objE.fieldG = null;  // 2.写
objD.fieldG = G;     // 3.写
```

读写屏障就是在读写前后加入一些操作，类似 AOP

**G1 解决**：**写前屏障** + **SATB** **原始快照** ；  SATB （Snapshot At the Beginning）沿用 **开始时的对象图**，在 GC Root 确定好之后，就 stop the world 确定当时的视图。当 E 的成员变量 G 引用发生变化时记录一下。并发标记完后，再将这些灰色对象为根，重新扫描一次。

**CMS**：**增量更新 - 写后屏障**：当 D 需要增加成员时，**记录下来等待遍历**。可以理解为 黑色对象增加一个白色对象后，它就变回灰色对象。

SATB不需要在重新标记阶段再次深度扫描被删除的引用对象



### 不可达一定回收吗？

如果这个对象包含了finalize函数

1. 第一次标记（判定为不可达）后 ---> **有必要执行 finalize()** ，**加入队列中**，
2. 稍后由一个  **`Finalizer` 线程** 去执行队列中对象的`finalize()` （可以在里面自救，与引用链中对象建立引用关系）方法
3. 第二次标记，也是最后一次，把不可达的回收。

没有必要执行 finalize，应该就直接拜拜 ： 对象没有覆盖 finalize()；finalize已经被调用过





## 四种引用

**JDK 1.2** 之前，一个对象只有被引用和没有没引用两种状态，稍显死板。比如 **缓存**，由于缓存的对象一直被引用，缓存可能耗尽内存。

**强引用**：a = b, 即使 **OOM 也不会回收具有强引用的对象**；**GC root可达**

**软引用**：**如果内存不足**，**存活一定时长** 就会回收；适用于 **有用但非必需**，**cache**； **内存熔断**，当内存不够分配时，可以提醒上层服务；SoftReference<>(Obeject obj) 创建，	soft.get()	获取

**弱引用**：发现就回收；应用于**缓存**，**WeakHashMap**（Map 中的 key 为弱引用，GC时会被清理，value为强引用，但随后会被 expungStaleEntries（）移除。可以配合 concurrentHashMap 实现 **热点缓存**（tomcat 的简易缓存 ConcurrentCache）；也应用到了 **ThreadLocal**

**虚引用**：和没有引用一样，会 get到null；可以被加入 到 ReferenceQueue 对象中，用来跟踪对象被垃圾回收的状态。





# 内存模型

**线程私有**

**程序计数器**： 当前线程所**执行字节码的行号指示器**；**java方法**的话，值为**正在执行的字节码指令的地址**，如果执行 **native 方法，计数器值为空**；该区域**大小固定**，不会抛出 OOM

**虚拟机方法栈**：描述 java **方法** 的内存模型，栈帧中存储方法的**局部变量表**，方法出口，动态链接？？，

**本地方法栈**：类似上面，但是存储 native 方法 （这俩会抛出 OOM 和 StackOverflowError ）

**线程共享**

**堆**：存储对象，最大，GC 算法主要应用于堆，可以细分为老年代，新生代（又可以分为 Eden空间，两个 Survivor 空间），有OOM

**方法区**：（逻辑上属于堆的一部分，但是为了与堆区分，又叫非堆）存放已经被加载的 **类信息**，**常量**，**静态变量**，包含**运行时常量池**（存储 Class 文件中的常量池（字面量-就是赋值语句右边的，和符号引用） 会在**类加载后** 被放入这个区域）





### 导出内存

1. 使用 **jmap -dump:format=b, file=/dumps/jmap.hprof  pid** 命令; jmap -heap pid **可以查看堆内存配置情况**，**使用情况**
2. 设置 **JVM** 参数，在内存溢出时自动 dump 出快照文件，-XX: **HeapDumpOnOutOfMemoryError**    -XX:HeapDumpPath = ...



### 死循环

该线程 CPU 占有率

CPU 负载



### 内存泄漏

代码中无用的强引用没有释放，导致无法被 垃圾收集器回收；

如果数量少还好，数量大的话可能导致  **Java堆溢出**，栈溢出，（方法区内）常量池溢出，



### 参数

| -Xms                     |                          初始堆大小                          | 物理内存的1/64(<1GB) | 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制. |
| ------------------------ | :----------------------------------------------------------: | -------------------- | ------------------------------------------------------------ |
| **-Xmx**                 |                          最大堆大小                          | 物理内存的1/4(<1GB)  | 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制 |
| **-Xmn**                 |                   年轻代大小(1.4or lator)                    |                      | **注意**：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。 整个堆大小=年轻代大小 + 年老代大小 + 持久代大小. 增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8 |
| **-XX:NewSize**          |                 设置年轻代大小(for 1.3/1.4)                  |                      |                                                              |
| **-XX:MaxNewSize**       |                  年轻代最大值(for 1.3/1.4)                   |                      |                                                              |
| -XX:PermSize             |                  设置持久代(perm gen)初始值                  | 物理内存的1/64       |                                                              |
| -XX:MaxPermSize          |                       设置持久代最大值                       | 物理内存的1/4        |                                                              |
| **-Xss**                 |                    **每个线程的堆栈大小**                    |                      | JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右 一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长） 和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:"” -Xss is translated in a VM flag named ThreadStackSize” 一般设置这个值就可以了。 |
| -*XX:ThreadStackSize*    |                      Thread Stack Size                       |                      | (0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.] |
| -XX:**NewRatio**         | **年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)** |                      | -XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5 Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。 |
| -XX:**SurvivorRatio**    |               **Eden区与Survivor区的大小比值**               |                      | 设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10 |
| -XX:LargePageSizeInBytes |         内存页的大小不可设置过大， 会影响Perm的大小          |                      | =128m                                                        |





## 类加载

- Bootstrap ClassLoader 启动类加载器： 加载 java 核心类库，lib/rt.jar

- Extention ClassLoader 标准扩展类加载器: 加载目录 lib/ext 下 jar 和class

- Application ClassLoader 应用类加载器 ： 加载 当前应用 classpath 下的类

- UserClassLoader 用户自定义类加载器： 加载指定 路径

  #### 双亲委派

**当一个类加载器收到了类加载的请求的时候，他不直接加载，而是委托给父加载器来加载，父加载器无法加载，才会由当前classLoader来加载**

避免重复加载，安全性（bootstrap classloader 只加载核心类库的类）

实现：classloader 里面的 private final ClassLoader parent; 父加载类为空，则默认使用 启动类加载器作为 parent

**loadClass**(String name, boolean resolve) 内部委托 parent 加载，如果 父加载器加载失败，就调用 **findClass**() 来完成加载。

### 打破双亲委派的案例

破坏：自定一个类加载器，重写其中 loadClass() 方法。

当一个类**被 根加载器加载后**，还需要加载其他 第三方类时，根据双亲委派原则，第三方的类不能被根加载器加载，此时 引入 **ThreadContextClassLoader** 





## 可作为GC Roots的对象有哪些？

1. 虚拟机栈，本地方法栈 引用的对象

2. 方法区中类静态属性，常量引用的对象

   

## 什么情况下类会被卸载？

需要同时满足以下 3 个条件，类才可能会被卸载 ：

- 该 **类所有的实例都已经被回收**
- 加载**该类的类加载器已经被回收**
- 该**类对应的 `java.lang.Class` 对象没有在任何地方被引用**，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的类进行**可以回收，但不一定**会进行回收。



## Minor GC 和 Full GC的区别？

- **Minor GC**：回收新生代，因为新生代对象存活时间很短，因此 `Minor GC`会频繁执行，执行的速度一般也会比较快。
- **Full GC**：回收老年代和新生代，老年代的对象存活时间长，因此 `Full GC` 很少执行，执行速度会比 `Minor GC` 慢很多。



## 对象分配策略

？ minor GC, 大对象？ 2 survior, 动态年龄？



## 垃圾回收算法

标记-清除： 内存碎片

标记-复制：分两个内存区域

标记-整理： 向一端移动



## 类加载

**加载**

1. 通过类的全限定名获取定义此类的**二进制字节流**
2. 将**字节流所代表的静态存储结构**转换为 **方法区的运行时数据结构**
3. 在内存中生成一个代表该类的`Class`对象，作为方法区类信息的访问入口

**验证**

确保Class文件的字节流中包含的信息符合虚拟机规范，保证在运行后不会危害虚拟机自身的安全。主要包括四种验证：**文件格式验证，元数据验证，字节码验证，符号引用验证**。

**准备**，内存分配，变量初始值设置

**为类变量分配内存**， 并 **设置类变量初始值** 的阶段。

**解析**，符号引用 -> 直接引用

虚拟机**将常量池内的符号引用替换为直接引用**的过程。符号引用用于描述目标，直接引用直接指向目标的地址。

**初始化**

开始执行类中定义的`Java`代码，初始化阶段是调用类构造器的过程。





## 对象创建过程

类加载检查：能否在 **常量池**中定位到这个类的 **符号引用**，检查是否已经被加载，解析，初始化过

分配内存：为对象实例分配内存， TLAB （线程私有内存空间） + CAS

初始化： 内存空间 初始化为 零值，包装对象的字段可以不赋值直接使用

设置对象头：自身运行时数据（哈希码，GC 分代年龄，锁状态标志），类型指针（类元数据）

按照 java 代码初始化



## G1

G1将整个堆分成相同大小的分区（`Region`），有**四种不同类型**的分区：`Eden、Survivor、Old和 Humongous`。分区的大小取值范围为 1M 到 32M，都是2的幂次方。分区大小可以通过`-XX:G1HeapRegionSize`参数指定。**Humongous** 区域用于存储大对象。G1规定只要大小超过了一个分区容量一半的对象就认为是大对象。

**特点**：可以由用户**指定** **期望的垃圾收集  停顿时间**。



**初始标记**  暂停所有其他线程，记录直接与 `GC Roots` 直接相连的对象，耗时较短 。

**并发标记**  从`GC Roots`开始对堆中对象进行可达性分析，找出要回收的对象，耗时较长，不过可以和用户程序并发执行。

**最终标记** 需对其他线程做短暂的暂停，用于处理并发标记阶段对象引用出现变动的区域。

**筛选回收**  对各个分区的**回收价值和成本**进行排序，根据**用户所期望的停顿时间**来制定回收计划，然后把决定回收的分区的存活对象**复制**到空的分区中，再清理掉整个旧的分区的全部空间。这里的操作涉及存活对象的移动，会暂停用户线程，由多条收集器线程并行完成。



### 哪些区域会内存溢出，为什么

堆：不断创建对象并触发 GC，但是GC 后仍有大量对象存活；一般 **高并发时  内存泄露**

虚拟机栈，本地方法栈，当线程申请的栈大小 大于栈最大空间 -Xss ；

方法区：不断创建类时，

程序计数器不会，因为其大小固定

### 垃圾回收[算法]() 

标记清除，标记复制（分为两部分，把留下的复制到空的部分，剩下的清楚），标记整理 （移动到一端）
