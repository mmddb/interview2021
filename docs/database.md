## 索引

按数据结构分类可分为：**B+树索引、Hash索引、Full-text索引**（关键字，文章id）
按物理存储分类可分为：**聚簇索引、二级索引（辅助索引）**。
按字段特性分类可分为：**主键索引、普通索引、前缀索引**。
按字段个数分类可分为：**单列索引、联合索引（复合索引、组合索引）**。



### 聚簇索引，非聚簇索引

**数据和索引**放在一起存储，索引结构的叶子节点保留了数据行；

**数据和索引**分开存储，索引叶子节点存储的是指向数据行的地址；

在 Innodb中，默认索引为 B+ 树，非聚簇索引（辅助索引）叶节点中存的是主键，可能需要回表。（索引覆盖的问题，如果非聚簇索引上可以获取到需要的值，就不用拿着主键去主索引上了）

MyISAM 中，都是非聚簇索引



### B+树和B树

B+内部节点只存储键，B树内部节点要存储数据和键。（空间利用率高 ---> 高度变低，查找快速，IO少）

B+树叶子节点相连（更方便进行范围查找，顺序遍历）

B+树搜索较为稳定，每次查询都是根节点到叶节点

B树：存在热点数据的访问时，可以把频繁访问的值放在离根节点近的地方，加快检索

### 设计原则

区分度越高越好： ？？

尽量使用短索引：例如使用较长字符串的前缀（前缀索引）， ？？ -> 查询速度更快

利用最左前缀：

不要过度设计索引，索引占用物理空间，并且有维护开销。



### 最左前缀匹配

从联合索引的左边为起点开始匹配，遇到范围查询（< > LIKE Between）会停止



### 索引失效

查找语句 在**索引字段**上，进行 **计算**，**函数操作**，**数据类型不一致**，使用 **!= ，is (not) NULL, < >**  



## MVCC

不加锁情况下，解决数据库读写冲突问题

InnoDB 的**行数据**有多个版本，每个版本有自己的 **trx_id**，每个事务有自己的 **up_limit_id**.（**事务开始时**，系统里面已经提交的事务最大 ID，表示这是我可以看到的），如果一个数据版本的 row_trx_id > up_limit_id，我就不认，就通过行数据中 roll_trx_ptr 来找寻之前的版本。

trx_id 在事务开始的时候向 InnoDB申请的，按照申请顺序严格递增。

Read Committed 的话，每一次 select 都找那个 up_limit_id

Repeatable Read 的话，事务只在开始的时候获取一次 up_limit_id

**但是表结构的更改，看不见，因为没有表结构没有对应的行数据。**

**更新数据是先读后写**的，这个读读的是当前值，成为 “当前读”



**update 会阻塞，第二个 update 会被阻塞。** 因为 **加了行锁**



## 日志

#### redo log (engine layer)，两阶段提交

当一条记录需要更新时，InnoDB 先写到 redo log中，并更新内存，当时机合适（写满，）的时候，刷入磁盘中。引擎层，负责 存储相关

#### binlog (server layer)

server层，负责功能相关； 逻辑日志

#### 区别

特有；server层，所有引擎都能用

物理日志，“某个**数据页**，做了什么更改”； 逻辑日志，”给 id = 2 的行加 1“

redo log循环写，会覆盖； bin log 追加写入，不会覆盖

#### 两阶段提交

事务完成更新操作，更新到内存 ——  **写入 redo log**， 处于 **prepare** 阶段 —— **写 bin log** —— 提交事务，redo log 处于 commit 阶段



### 引擎区别

事务；恢复；外键；最小锁粒度，innodb 行，myisam 表



### mysql 的锁



## 事务

 一系列对数据库的操作，要么全部执行，要么全部不执行，是一个不可分割的工作单位。





### 查询很慢 ？？

用到索引？正确识别索引？

索引失效：没用到最左前缀匹配，

#### 优化器

优化器会选择索引，依据是 **索引基数**（采样统计），**预估扫描行数（标记删除的记录，还在表文件内部，导致记录逻辑上已经删除掉的; 用 analyze table 重新统计一下），是否需要排序，**；

解决：force inedx(a) 强制使用索引； 诱导优化器，如果优化器是因为觉得选a会排序，那么把 b 也加入排序。





### 锁

**全局锁**：给库加的，使里面的表完全只读；命令 **Flush tables with read lock** **(FTWRL**)；可以用于全库逻辑备份，但是会造成 —— **业务停摆**，**从库无法执行 主库同步过来的 binlog**，主从延迟； 

当引擎**支持可重复读隔离级别**时， 更好的方法是，在备份过程中使用事务， -single- transaction 参数，**获取一致性视图**？； 备份系统时，在下，**最好使用事务**来获取一致性视图；

**表锁** ： **普通表锁**：对表施加 **写锁**，**读锁**；**不仅限制别的线程，也限制本线程接下来的操作**，如 读锁，会限制本线程也不能写 ; lock tables t1 read, t2 wirte; unlock tables 解锁。

**MDL 锁**：meta data lock, **锁的是表结构**; 访问一个表的时候会自动加 **MDL 读锁**，别的线程 alter **修改表结构会** **block**； 结构变更要加 MDL 写锁； 读锁不互斥，写锁互斥，只能有一个写，别的要等。 注意：MDL 锁一直到事物提交才会释放；最**好设置写锁获取时阻塞超时时间**；**减少长事务**；以免 ；**申请MDL锁的操作会形成一个队列**，队列中**写锁获取优先级高于读锁**，**如果写锁出现等待，会阻塞后续的读锁**

**行锁** ：在需要的时候加上，事务结束再释放，**两阶段锁协议**



### **长事务**

保留过多的 回滚段；占用锁资源，拖垮整个库





## **Redis** 高可用，哨兵模式**主节点挂了怎么选举节点**，叙述过程 

判断是否真的挂了 （半数以上同意，客观下线，主观下线）

选主（哨兵确认主观下线后，请求别的节点投票，别的节点没投过就是同意，投了就是不同意；最终得票 大于半数以上，并且大于 quorum 配置项）

筛选（之前网络条件不好的 去除）

打分（自定义的优先级，主从复制进度，id 小的优先）