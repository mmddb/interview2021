

动态规划：

1. 最长回文字串：重用已经判断好的 回文，循环时 ，外层为长度 l，内层为起始点 i，这样保证初始化每一个字母为回文。dp i j = dp i+1 j-1 && char[i] == char[j]
2. 最大子序和：dp i = max(dp i-1 + num[i] , num[i]), 记录最大值即可
3. 编辑距离：dp i j 代表两个字符串中前 i，j个，最终返回 dp m n，
4. 最长子序列：dp[i] = Max(dp[i], dp[j] + 1) ( 0 < j < i, if nums[j] > nums[i] ) 



贪心：

1. 跳跃游戏II：维护当前可跳到的范围，[start，end]，更新能跳到的最大距离。

2. 跳跃游戏：在一个不断变化的 cover 范围内遍历，用范围内的点获得增大 cover，cover = Math.max(cover, i + nums[i]);
3. 



哈希：

1.交换和：移动一对 -> 两列表相等，那么他们的差值一定为 偶数，然后 带着预期值遍历 即可





二分：

1. 最小差的 pair：先排序，然后按照 **合并两个有序数组一样**，不断更新最小差值。







单调栈：栈底最大，栈顶最小。

用于找 左边，右边第一个大于 它的值

1. 每日温度：用栈存idx，新来的如果大于 top的值，那就一直 pop，并计算 result[idx] = i - idx，最后也进去. 小于等于直接进去。

接雨水：一列一列算，Min（左边最高，右边最高）- 当前高度，就是水的量，注意水量要大于 0； 优化，可以用两个 dp[] 存一下 从左到右，从右到左的最大高度表



### 数组：

#### 滑动窗口：右边界一直走，区间定义取决于题目

类似双指针，for(int r = 0; r < nums.length; r++)， 用 while 维护一个窗口（满足题目要求）

水果成篮：最长序列（只包含两个不同值），区间定义为（map size <= 2）

最小覆盖子串：两个 Map 一个存 原始字母数量表，另一个存遍历时的各个字母以及数量。

窗口内（cnt 的各个数量大于 ori的）



#### 双指针： 慢指针做事，快指针找

1. 删除重复：快慢指针刚开始就错开一下。 不一样的时候，快指针指向 赋值给慢指针指向下一个。
2. 删除特定的值：不用错开。
3. 有序数组的平方：指向两边的指针，选大的放到结果数组里面，从后往前

