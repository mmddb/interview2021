## 死锁条件

解决



### 视图优点

第一点：  使用视图，可以**定制用户数据**，**聚焦特定的数据**。 

 解释：在实际过程中，公司有不同角色的工作人员，我们以销售公司为例的话，采购人员，可以需要一些与其有关的数据，而与他无关的数据，对他没有任何意义，我们可以根据这一实际情况，专门为采购人员创建一个视图，以后他在查询数据时，只需select * from view_caigou 就可以啦。 

 第二点：使用视图，**可以简化数据操作**。 
 解释：我们在使用查询时，在很多时候我们要使用聚合函数，同时还要显示其它字段的信息，可能还会需要关联到其它表，这时写的语句可能会很长，如果这个动作频繁发生的话，我们可以创建视图，这以后，我们只需要select * from view1就可以啦，这样很方便。 

 第三点：使用视图，**基表中的数据就有了一定的安全性** 
 因为视图是虚拟的，物理上是不存在的，只是存储了数据的集合，我们可以将基表中重要的字段信息，可以不通过视图给用户，视图是动态的数据的集合，数据是随着基表的更新而更新。同时，用户对视图，不可以随意的更改和删除，可以保证数据的安全性。 



### **SQL** 安全性

1.防止sql注入,对特殊字符进行转译与过滤,使用 sql 语句绑定变量

2.**最小用户权限设置**,最好不要使用root用户连接数据库

3.**当sql运行出错的时候,不要将错误信息全部显示给用户**



### 数据库连接池

C3P0

HikariCP

Druid



### 分库分表

先垂直分，再水平分；较为简单

垂直分：单表 按字段分为多个表； 



**水平分**：

1. 查询切分：将 id 和库的 映射关系，记录在一个单独的库中

   优/缺：ID 和 库的 Mapping 算法可以随意更改； 引入额外的单点

2. 按范围：时间区间，id区间来切分； 单表大小可控，天然水平扩展； 但是无法解决集中写入瓶颈的问题。

3. hash取模  



**面临问题**

事务，跨库 join，



### 分布式 session

客户端存储，session 复制

基于 redis：从 redis 中取



### 前端 **axios** 发送， 协议，格式

###  并发量上不去咋办







## RESTful 好处

1. **简单并且易于理解**：使用 URI 标志性资源，HTTP 方法定义动作
2. **无状态**；减轻服务器压力，前后端分离。
3. **超文本驱动**，在返回的内容中可以嵌入 超文本，来指导前端后续操作。可维护性和扩展性会很好。







| **验证 validate** | **验证项目** | **验证项目是否正确且所有必须信息是可用的**                   |
| ----------------- | ------------ | ------------------------------------------------------------ |
| **编译 compile**  | **执行编译** | **源代码编译在此阶段完成**                                   |
| **测试 Test**     | **测试**     | **使用适当的单元测试框架（例如 JUnit ）运行测试。**          |
| **包装 package**  | **打包**     | **创建JAR/WAR包如在 pom.xml 中定义提及的包**                 |
| **检查 verify**   | **检查**     | **对集成测试的结果进行检查，以保证质量达标**                 |
| **安装 install**  | **安装**     | **安装打包的项目到本地仓库，以供其他项目使用**               |
| **部署 deploy**   | **部署**     | **拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程** |





### MVC 模式是什么以及优缺点 

**一种应用设计模式**

**模型(model)** 它是 应用程序的**主体部分**，主要包括业务**逻辑模块**和**数据模块**。模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性
**视图**(view) **用户与之交互的界面**、在 web 中视图一般由jsp,html组成
**控制器**(controller) **接收来自界面的请求并交给模型进行处理** 在这个过程中控制器不做任何处理只是起到了一个连接的作用

1、**降低耦合**。在MVC模式中，三个层各施其职，所以如果一旦哪一层的需求发生了变化，就只需要更改相应的层中的代码而不会影响到其他层中的代码。
2、**分工合作**。在MVC模式中，由于按层把系统分开，那么就能更好的实现开发中的分工。网页设计人员可进行开发视图层中的 JSP，而对业务熟悉的人员可开发业务层，而其他开发人员可开发控制层。
3、**组件重用** 。如控制层可独立成一个能用的组件，表示层也可做成通用的操作界面。可以为一个模型在运行时同时建立和使用多个视图。



 1、**增加了系统结构和实现的  复杂性**。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。
2、**视图与控制器间的过于紧密的连接**。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。



##  Spring MVC怎么分层 

- **表示层**：**页面展示，请求分发**。 **DispatcherServle**t 分配请求給 ， **Controller** 调用 业务层
- **业务层**：业务处理接口和实现。 调用 
- **持久层**：数据访问和持久化。 被

## **Redis** 高可用，哨兵模式**主节点挂了怎么选举节点**，叙述过程 

判断是否真的挂了 （半数以上同意，客观下线，主观下线）

选主（哨兵确认主观下线后，请求别的节点投票，别的节点没投过就是同意，投了就是不同意；最终得票 大于半数以上，并且大于 quorum 配置项）

筛选（之前网络条件不好的 去除）

打分（自定义的优先级，主从复制进度，id 小的优先）



## Stringbuilder 和 Stringbuffer区别，哪个效率更高 

这俩都继承自 **抽象类 AbstractStringBuilder**, 底层 char数组，

StringBuffer 除了构造方法外，基本都被 **Synchronized** 修饰

StringBuilder 重写了 insert，append方法 以接受更多的 数据类型



## hashmap 和 hashtable区别，hashmap底层结构，hashmap 为什么线程不安全 

4 个 区别：**线程安全**；允许 **null** ？；

Hashtable计算hash是直接**使用 key的hashcode对table数组的长度直接进行取模**
**HashMap ** 把得到的 hashcode 进行了**二次hash**，以获**得更好的散列值**，然后对 table数组长度取模

HashMap的**初始容量**为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。HashMap扩容时是当前容量翻倍即:`capacity` *`2`**，Hashtable扩容时是容量翻倍+1即:**`capacity`* `(2+1)`



Hashtable： **get 都使用了synchronized**描述符。而**遍历视图比如keySet都使用了Collections.synchronizedXXX进行了同步包装**



底层： node<K,V> 数组，链表，红黑树

1.7 扩容死循环？？

1.8 **put时**，**丢失修改**；如果两个线程都判断没有 hash 碰撞，直接插入，第一个线程插入后被挂起，第二个的线程会 冲掉刚改的值



### 四次挥手





### 快排



### 操作系统：linux常用指令

目录跳转：cd, cd -, cd ~, mkdir, ls, pwd

文件：vim, touch, rm, 

打开：cat, more, less, head, tail, 

修改：cp, scp, mv

高级一点的：sed, grep

当前进程：lsof, netstat, ps

权限：chmod,



### 计算机网络：简单讲下 TCP 流量控制机制 

**流量控制**：滑动窗口：接收方发送 **缓存区剩余容量** + 报文

接收方每次收到数据包，可以在发送确定报文的时候，同时告诉发送方**自己的缓存区还剩余多少是空闲的**，我们也把缓存区的**剩余大小**称之为接收窗口大小，用变量win来表示接收窗口的大小。

发送方收到之后，便会调整自己的发送速率，也就是**调整自己发送窗口的大小**，当发送方收到接收窗口的大小为0时，发送方就会**停止发送数据**，防止出现大量丢包情况的发生。

**拥塞控制**：慢启动，加分增，乘法减少



### 抽象类和常用类区别、String常用类 

abstract 修饰，必须要有抽象方法，不能被实例化，只能用于继承；



### 数据库有哪些优化方法、索引的创建、有哪几种索引

1. **排除缓存干扰**

2. 索引**尽量区分度高**，**占用空间小**

3. 利用 **最左匹配** 原则

4. 使用 **覆盖索引**，避免回表

5. 很长的字段建立 **前缀索引**

   



### Redis 缓存

**缓存雪崩** 是指**大量的应用请求****无法在 Redis 缓存中进行处理**，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。

大量数据同时过期，redis 宕机

**缓存击穿** 是指，针对 **某个** 访问非常频繁的热点数据的请求，无法在缓存中进行处理。

原因：**热点数据过期失效时**

**缓存穿透** 是指**要访问的数据既不在 Redis 缓存中，也不在数据库**中。

业务层误操作: 数据被误删除了

恶意攻击:专门访问数据库中没有的数据。



## 建立索引的一些原则

区分度高，占用空间小

长字段使用 **前缀索引**

覆盖索引，最左匹配原则

为经常需要**排序、分组和联合**操作的字段建立索引

不要建立冗余的



## 执行顺序

```sql
(8) SELECT (9)DISTINCT<Select_list>
(1) FROM <left_table> (3) <join_type>JOIN<right_table>
(2) ON<join_condition>
(4) WHERE<where_condition>
(5) GROUP BY<group_by_list>
(6) WITH {CUBE|ROLLUP}
(7) HAVING<having_condtion>
(10) ORDER BY<order_by_list>
(11) LIMIT<limit_number>
```



## 为什么重写equals方法的时候要重写hashcode方法？ 



面向对象的优点？ 



内存泄漏和内存溢出的区别？ 



ArrayList和LinkedList的区别？ 



ArrayList和Vector的区别？ 



List、Set、Map各有什么特点？ 



Map、HashMap、HashTable、CurrentHashMap、LinkedHashMap 、LinkedMultiValueMap的区别？ 



异常的概念、分类和处理 



IO流的概念、分类和基本方法 



多线程的概念、原理、优缺点 



乐观锁和悲观锁的区别？ 



进程和线程的区别？ 



同步和异步的区别？ 



sleep和wait的区别？ 



线程同步的相关方法有哪些？ 







### 应用层， 传输层有什么协议 网络层呢 链路层

BGP 边界网关协议，DHCP 自动分配IP地址，DNS，FTP，HTTP，HTTPS，IMAP，SMTP，SSH，Telnet

TCP，UDP，TLS（传输层安全性协议）/ SSL，SCTP（流控制传输协议）

IP，ICMP 发送控制消息，IGMP， OSPF 开放最短路优先，RIP 路由信息协议，

ARP 地址解析协议，PPP 点对点，MAC 媒体接入控制，实现多路访问，分时，分频，分波



### HTTPS 对称非对称，密钥谁生成（接收方） 用了什么加密算法

**经由[HTTP](https://zh.wikipedia.org/wiki/HTTP)进行通信**，但**利用 SSL/TLS  来[加密](https://zh.wikipedia.org/wiki/加密)数据包**; 对**工作在一加密连接（[TLS](https://zh.wikipedia.org/wiki/传输层安全)或SSL）上的常规HTTP协议的称呼**

**混合的**，使用非对称加密 交换 （稍后共享密钥加密中要使用的密钥），确保交换密钥安全的情况下，使用共享密钥加密方式进行通信。

**接收方生成**，公钥（加密），私钥（解密）； 发送方用公钥加密

TLS ， SSL 啥区别： **TLS 是 SSL的标准化后的产物** （应用层和传输层之间）

非对称做 **身份认证**，之后交换 **对称密钥**，作为会谈密钥 







## redis 













